Abstraction:
Abstraction is the process of breaking down a concept by dividing it into layers of individual parts of increasing simplicity. These layers both divide processes that are otherwise unrelated and reveal that many processes are composed of similar components which has many benfits including allowing the interchanging of means of performing a given task without worrying about changing it in multiple locations or requiring adjustments across the entirety of the project. When writing my Lapis Mapper program, a prior project of mine written in pure C, I used abstraction by creating a series of structs and functions which were able to encode, decode, and navigate the binary file format I was working with. These functions were then able to be used throughout my code to fetch various pieces of information from the file without needing to rewrite the complex behaviors for parsing the format. Additionally, when errors arose, I was able to apply the fixes to a single place instead of everywhere in my code I referenced the file. Abstraction makes the program more flexible for future changes by isolating where the instructions for reading the file format are locating so that, if the format ever changes, it can be changed in the one place instead of requiring numerous changes throughout.
Encapsulation:
Encapsulation is the process and act of placing processes inside of distinct regions and limiting access between them. Encapsulation has an effect of making each class a self-sufficient part that can be used regardless of the greater context. This makes it significantly simpler and quicker to adjust how the part accomplishes its task or where the part is placed in the assembly by limiting the affected regions of code when such changes are performed and concentrating it into one, easily understood, location. In the week 3 assignment program, scripture memorizer, encapsulation was used by separating the references and words into separate classes from the scripture and making their own attributes private while only revealing the methods necessary to perform the needed interactions and get the final display results to be compiled in the scripture class. Encapsulation makes the program more flexible for future changes by allowing changes to how the references or words are stored to only require changes to the methods inside those classes instead of tracking them down across the other classes.
Inheritance:
Inheritance is a concept which allows one class to receive, or inherit, the properties of another. Inheritance makes it easy to create multiple similar classes or multiple versions of the same class. A basic example of how it works would be to say that "a dog is an animal": Dogs are not the only animals but all animals possess a set of similar traits which you can indicate that a dog has by stating it is an animal. Dogs also have several features unique to them, despite inheriting the properties of an animal, meaning they need their own designation and type. In a program I wrote for my previous class, I used inheritance to create multiple similar mesh and facet classes to be able to store 3d meshes in different formats to match the file format they were being read from without needing to rewrite many of the core methods and attributes for the meshes. Inheritance makes the program more flexible for future changes by making it easy to add additional mesh classes if ever needed.
Polymorphism:
Polymorphism is the property of something to take multiple forms. In the context of programming, this generally refers to the principle of using overloading and overriding to give a piece of code dynamic behaviors based on the surrounding context. Polymorphism allows simplifying operations which are similar in their inputs and outputs but vary in their execution. Polymorphism expands the principle of encapsulation by enabling various behaviors to be encapsulated under a single identifier. Referencing my 3d mesh program again, the derived mesh classes were used to handle mesh data in varied formats. Despite this, overriding was employed to be able to use all the derived classes interchangeably in the later code and be able to get the necessary data using the same line of code, regardless of which derived class was used. Polymorphism makes the program more flexible for future changes by allowing additionally added classes for new cases to be used without add new supporting code.